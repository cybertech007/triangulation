## БИБЛИОТЕКИ ##
import sys

import pygame
from pygame.locals import * # библиотека pygame

from random import randint
from math import floor      # библиотеки для просчета габаритов поля и рандомной генерации

from OpenGL.GL import *
from OpenGL.GLU import *    # библиотека 3D графики OpenGL

## ПРОСЧЁТ РАНДОМНОГО ПОЛЯ И ЗАПИСЬ В МАССИВ ##

width = 10 # ширина поля в еденицах измерения X
heigh = 10 # длинна поля в таких же еденицах X


poligon_x = floor(width)          # вычисленная ширина поля по количеству оснований сегментов поля (равнобедренных треугольников)
poligon_y = floor(heigh / 2 * 3)  # вычисленная длина поля по количеству высот сегментов поля (тех же треугольников)

vert = [[0] * (poligon_y + 1)] * (poligon_x + 1) # генерация двумерного массива из нулей ширины и длинны поля в вершинах треугольников (сегментов поля)

for i in range((poligon_x + 1)): # цикл генерации рандомных высот вершин в узлах сетки, чтобы на этих вершинах были построены равнобедренные непересекающиеся треугольники (триангуляция Делоне)
    rand = [0] * (poligon_y + 1) # создание пустого списка из нулей, по ширине поля в узлах (одна "строка" поля)
    for j in range((poligon_y + 1)):        # цикл записи в строку рандомных высот по полю
        rand[j] = randint(0, 30) / 50 - 2   # запись в одну ячейку рандомной высоты вершины
    vert[i] = rand  # запись строки в итоговый массив всех высот

## ФУНКЦИИ ПРОРИСОВКИ ТРЕУГОЛЬНИКА ПО ДАННЫМ ИЗ МАССИВА ПОЛЯ <<VERT>>, ИЗ КОТОРЫХ СОСТОИТ ПОЛЕ ##

edges = [   # номера вершин, соединяемых ребром в [a, b]
    [0, 1],
    [1, 2],
    [2, 0]
    ]

def genv(x, y, z, y1, y2):  # функция вызова функции по рисовке треугольника (элементарного сегмента поля, y - по высоте)
    s = [[x, y, z], [x + 3, y1, z], [x + 1.5, y2, z + 2]]  # по входным параметром определение XYZ вершин треугольника
    triflat(s)   # вызов функции рисовки с полученными координатами


def triflat(s):  # функция рисовки с треугольного сегмента

    glBegin(GL_LINES) # сам разбираюсь, видимо подготовка, установка типа линий

    for edge in edges: # перебор рёбер из массива <<edge>>

        for vertex in edge: # перебор двух вершин ребра

            glVertex3fv(s[vertex]) # функция соединения вершин ребром

    glEnd() # 

## MAIN ##

def main():
    g = 0   # индикатор направления прыжка на момент
    t = 0   # угол, на который в каждой итерации цикла изменяется общий поворот камеры влево/вправо в градусах
    u = 0   # скорость прыжка
    x = 0   # скорость движения по X
    y = 0   # скорость движения по X
    xx = 0  # X нулевого угла поля
    yy = 0  # Y нулевого угла поля
    tt = 0  # общий угол в градусах поворота камеры влево/вправо на данный момент
    uu = 0  # общая высота прыжка на данный момент
    
    pygame.init() # запуск pygame

    display = (1880, 1000) # размеры дисплея

    pygame.display.set_mode(display, DOUBLEBUF|OPENGL) # вывод окна дисплея pygame с "двусторонним экраном" с библиотекой OPENGL

    gluPerspective(50, (display[0]/display[1]), 0.1, 50.0) # перспектива: угол видимости, ширина/высота дисплея, <<?>>, радиус видимости

    glTranslatef(0, 0, 0) # точка XYZ, в которой распологается "камера"

    while True: # основной цикл pygame
        
        for event in pygame.event.get():  # цикл просмотра событий pygame

            if event.type == pygame.QUIT and u == 0:  # если ничего не происходит, вылет из итерации
                
                pygame.quit()

                quit()
            
            elif event.type == pygame.KEYDOWN:  # просмотр нажатых клавиш для перемещения камеры (на самом деле всего окружающего в другую сторону), запись в переменные для функции прорисовки
                
                if event.key == K_ESCAPE:
                    sys.exit()
                
                if event.key == pygame.K_LEFT:    # влево
                    x = 1
                
                elif event.key == pygame.K_RIGHT: # вправо
                    x = -1
                    
                elif event.key == pygame.K_DOWN:  # назад
                    y = -1
                    
                elif event.key == pygame.K_UP:    # вперёд
                    y = 1
                    
                elif event.key == pygame.K_a:     # поворот камеры влево
                    t = -1
                    
                elif event.key == pygame.K_d:     # поворот камеры вправо
                    t = 1
                
                elif event.key == pygame.K_w:     # прыжок
                    if u == 0:
                        g = 1
                        u = -0.7
                        uu = -0.7
                    
            elif event.type == pygame.KEYUP:
                t = 0
                x = 0
                y = 0
                
        glTranslatef(0, 0, 0) # XYZ камеры (не меняется, меняется XYZ поля)
        glRotatef(2, 0, t, 0) # поворот камеры
        
        if uu > -1.7 and g == 1: # замедление скорости прыжка
            u = u / 3 * 2
        
        elif uu < -1.7: # начало падения после прыжка
            g = 0
            u = -u
        
        elif uu < -0.1 and g == 0: # падение
            u = u / 2 * 3
        
        else: # конец
            u = 0
            uu = 0
        
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)  # очистка экрана
        
        # прибавление изменений в одной итерации к общим изменениям
        uu += u
        tt += t
        xx += x * 3
        yy += y * 2
        hill = 0
        
        # вызов во вложенном цикле функции рисовки треугольника для заполнения поля этими сегментами
        
        for i in range(poligon_x):
            for j in range(poligon_y):
                genv(i * 3 + xx + 1.5 * (j % 2), vert[i][j] + uu + hill, j * 2 - 50 + yy, vert[i+1][j] + uu + hill, vert[i + j % 2][j+1] + uu + hill) 
                

        pygame.display.flip() # переворот двустороннего экрана

        pygame.time.wait(1)   # задержка

## ЗАПУСК MAIN ##

main()